name: Frenglish Translation

on:
  push:
    branches:
      - '**' # Trigger on push to any branch
permissions: # <-- Control what the automatic GITHUB_TOKEN can do
  contents: read

jobs:
  translate_and_format:
    # Run on push events, but skip if the commit message indicates it's a merge commit
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, 'Merge pull request')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write # Keep if needed, otherwise can remove
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0 # Fetch all history for git diff to work reliably

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18' # Or your preferred Node.js version >= 16

      - name: Install dependencies
        run: |
          # Ensure you have a package.json and package-lock.json
          # Add @frenglish/sdk to your package.json: npm install @frenglish/sdk --save
          npm install

      - name: Setup Git User
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Get Language Configuration
        id: get_lang_config
        # --- CORRECTED SCRIPT NAME ---
        run: node .github/scripts/fetch-frenglish-configuration.js
        env:
          FRENGLISH_API_KEY: ${{ secrets.FRENGLISH_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # --- Step to Handle Renamed/Deleted Files ---
      # --- Step to Handle Renamed/Deleted Files (MODIFIED for Root Dir Support) ---
      - name: Handle Renamed and Deleted Source Files
        id: handle_changes
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          # set -o pipefail # Good practice for pipelines

          # Get config from the previous step's outputs
          SOURCE_DIR_RAW="${{ steps.get_lang_config.outputs.source_lang }}"
          TARGET_DIRS_STRING="${{ steps.get_lang_config.outputs.target_langs }}" # Use string temporarily
          BEFORE_SHA="${{ github.event.before }}"
          CURRENT_SHA="${{ github.sha }}"

          # --- Logic to determine effective source path ---
          EFFECTIVE_SOURCE_PATH="." # Default to root
          IS_SOURCE_ROOT=true
          if [[ -n "$SOURCE_DIR_RAW" && "$SOURCE_DIR_RAW" != "." && "$SOURCE_DIR_RAW" != "/" ]]; then
            # If SOURCE_DIR_RAW is not empty, '.', or '/', treat it as a subdirectory
            EFFECTIVE_SOURCE_PATH="$SOURCE_DIR_RAW"
            IS_SOURCE_ROOT=false
            echo "Source language files are expected in subdirectory: $EFFECTIVE_SOURCE_PATH"
          else
            echo "Source language files are expected in the root directory."
          fi
          # Clean potential trailing slash for consistency in prefix removal later
          EFFECTIVE_SOURCE_PATH_CLEAN="${EFFECTIVE_SOURCE_PATH%/}"

          # --- Validate configuration values ---
          # Source Lang is now handled by EFFECTIVE_SOURCE_PATH logic above, no separate check needed unless RAW value itself is mandatory.
          # Allow TARGET_DIRS to be empty if the SDK returned no targets, but log warning
          if [ -z "$TARGET_DIRS_STRING" ]; then
              echo "::warning::No target languages determined. Rename/delete actions for target directories will be skipped."
              echo "processed_changes=false" >> $GITHUB_OUTPUT
              exit 0 # Exit this step gracefully, not the whole job
          fi
          # Convert space-separated string to an array (handle empty string)
          read -r -a TARGET_DIRS <<< "$TARGET_DIRS_STRING"
           if [ ${#TARGET_DIRS[@]} -eq 0 ]; then
              echo "::warning::No target languages parsed. Rename/delete actions for target directories will be skipped."
              echo "processed_changes=false" >> $GITHUB_OUTPUT
              exit 0 # Exit this step gracefully, not the whole job
           fi


          # --- Conditional Source Directory Existence Check ---
          if [ "$IS_SOURCE_ROOT" = false ]; then
            # Only check existence if it's supposed to be a subdirectory
            if [ ! -d "$EFFECTIVE_SOURCE_PATH" ]; then
              echo "::warning::Expected source subdirectory '$EFFECTIVE_SOURCE_PATH' not found. Skipping rename/delete handling for this run."
              echo "processed_changes=false" >> $GITHUB_OUTPUT
              exit 0 # Exit gracefully
            fi
          fi
          # No check needed if IS_SOURCE_ROOT is true, '.' always exists.

          echo "Checking for renamed/deleted files in '$EFFECTIVE_SOURCE_PATH' between $BEFORE_SHA and $CURRENT_SHA..."
          processed_any_change=false # Use a flag to track if we do any git operation

          # Use NUL delimiters for robustness with filenames containing spaces/special chars
          # Target the EFFECTIVE_SOURCE_PATH
          git diff --name-status --find-renames -z $BEFORE_SHA $CURRENT_SHA -- "$EFFECTIVE_SOURCE_PATH/" | while IFS= read -r -d $'\0' status && IFS= read -r -d $'\0' old_path && IFS= read -r -d $'\0' new_path; do
            # Handle cases where new_path might not be present (for deletions)
            if [ -z "$new_path" ]; then
              new_path=$old_path # For deletion, new_path isn't set by git diff -z, old_path is the deleted one
            fi

            # --- Calculate relative paths correctly ---
            local relative_old_path
            local relative_new_path
            if [ "$IS_SOURCE_ROOT" = true ]; then
              # If source is root, the path IS the relative path
              relative_old_path="$old_path"
              relative_new_path="$new_path"
            else
              # If source is a subdirectory, strip the prefix
              # Use the cleaned path without trailing slash for stripping
              relative_old_path="${old_path#$EFFECTIVE_SOURCE_PATH_CLEAN/}"
              relative_new_path="${new_path#$EFFECTIVE_SOURCE_PATH_CLEAN/}"
            fi

            echo "Detected change: Status=$status, Old Path=$old_path, New Path=$new_path, Relative Path=$relative_old_path"

            for TARGET_DIR in "${TARGET_DIRS[@]}"; do # Iterate over array elements correctly
              if [ ! -d "$TARGET_DIR" ]; then
                echo "::warning::Target directory '$TARGET_DIR' not found. Skipping for this language."
                continue
              fi

              # Construct target paths using the calculated relative path
              target_old_path="$TARGET_DIR/$relative_old_path"

              if [[ "$status" == D* ]]; then
                if [ -f "$target_old_path" ]; then
                  echo "Deleting corresponding file: $target_old_path"
                  git rm "$target_old_path"
                  processed_any_change=true
                else
                  echo "Corresponding file not found for deletion: $target_old_path"
                fi
              elif [[ "$status" == R* ]]; then
                # Use relative_new_path for the target's new location
                target_new_path="$TARGET_DIR/$relative_new_path"
                target_new_path_dir=$(dirname "$target_new_path")

                if [ -f "$target_old_path" ]; then
                  if [ ! -d "$target_new_path_dir" ]; then
                      echo "Creating directory for renamed file: $target_new_path_dir"
                      mkdir -p "$target_new_path_dir"
                  fi
                  echo "Renaming corresponding file: $target_old_path -> $target_new_path"
                  git mv "$target_old_path" "$target_new_path"
                  processed_any_change=true
                else
                  echo "Corresponding file not found for rename: $target_old_path"
                   if [ -f "$target_new_path" ]; then
                      echo "Note: New target path '$target_new_path' already exists."
                  fi
                fi
              # Only processing Deletes (D) and Renames (R) based on original logic
              # elif [[ "$status" == A* ]] || [[ "$status" == M* ]]; then
                # Add/Modified files are handled by the translation script, ignore here.
              fi
            done # end loop target dirs
          done # end loop git diff

          # Output based on the flag
          echo "processed_changes=$processed_any_change" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run translation script (Writes/Updates files)
        env:
          FRENGLISH_API_KEY: ${{ secrets.FRENGLISH_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node .github/scripts/translate.js # Assumes this script exists and works

      - name: Run formatting script
        run: node .github/scripts/format-locales.js # Assumes this script exists and works

      - name: Stage ALL changes (new, modified, deleted, renamed)
        run: |
          echo "Staging all tracked changes (adds, modifications, deletes, renames)..."
          git add . # This stages all changes in the working directory

      - name: Commit changes
        id: commit
        run: |
          # Check index status after all operations (add, rm, mv)
          # Use --cached to check staged changes specifically
          if git diff --cached --quiet; then
             echo "No changes staged for commit."
             echo "changes_committed=false" >> $GITHUB_OUTPUT
          else
            echo "Committing translation updates, formatting, renames, and deletions..."
            # Use the dynamically fetched source language in the commit message
            COMMIT_SOURCE_LANG="${{ steps.get_lang_config.outputs.source_lang }}" # Capture output first
            git commit -m "chore(i18n): update translations [${COMMIT_SOURCE_LANG:-unknown}]" \
                       -m "Sync file structure, format locales. Branch: ${{ github.ref_name }}"
            echo "changes_committed=true" >> $GITHUB_OUTPUT
            git show --stat # Show commit details
          fi

      - name: Push changes
        # Only run if the commit step actually committed something
        if: steps.commit.outputs.changes_committed == 'true'
        run: |
          echo "Pushing changes to origin/${{ github.ref_name }}..."
          # Use --atomic for safety if supported, otherwise standard push
          git push origin HEAD:${{ github.ref_name }}